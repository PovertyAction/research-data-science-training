---
title: "The SQLite command line"
abstract: |
  Use the SQLite shell to re-run a file of SQL code. Save the output from the SQLite shell to a file.
date: last-modified

format:
  html: default

# Authors
authors-ipa:
  - "[Author Name](https://poverty-action.org/people/author_name)"

# Contributors
contributors:
  - "[Contributor Name](https://poverty-action.org/people/contributor_name)"

keywords: ["SQL", "Database", "Tutorial", "Data Science", "SQLite", "Command Line", "Shell"]
license: "CC BY 4.0"
---

::: {.callout-note}

## Learning Objectives

- Use the SQLite shell to re-run a file of SQL code
- Save the output from the SQLite shell to a file
:::

::: {.callout-tip}

## Key Questions

- How can I save my code in a file and run it again?
:::

## Running SQL code using the SQLite shell

Before you can run the SQLite3 shell program you must have installed it. Instructions for doing this are included in
the [set up procedures](../learners/setup.md).

I will assume that you have added the location of the program to your local PATH environment variable as this
will make it easier to refer to the database file and other files we may want to use.

The instructions in this episode are written from a Windows user perspective. If you are using Linux or a Mac,
open a terminal window instead a command prompt.

## Getting started with the SQLite shell

To start the shell, at a command prompt type `sqlite3` followed by the name of the database.
In our case the command is;

```bash
sqlite3 SQL_SAFI.sqlite
```

This should result in an output similar to the following;

```output
SQLite version 3.20.1 2017-08-24 16:21:36
Enter ".help" for usage hints.
sqlite>
```

The `sqlite>` is a prompt, similar to the `$` for the bash shell, indicating that SQLite is waiting for you to type in a query or command.
We can type any SQL query that we have used with the DB Browser application;

```sql
sqlite> select * from Farms limit 5;
```

![](figures/SQL_08_query_shell.png){alt='SQLite shell query'}

In the shell you will notice;

1. The column values are separated by a "|" character, not commas as they typically would be in a csv file.
2. NULL values appear blank.
3. There are no column names or headers provided.

If we are only returning 5 rows of data, then seeing it formatted like this in on the screen
may be OK. It is however more likely that not only are the results from the query somewhat larger,
but also we would prefer to save the output to a file for later use. There are some other changes to the output format that we might want to change as well.
for example; change the field separator from the default "|" to a comma and provide column headers. This will make the
output more like a standard csv file.

Notice that the `NULL` values in columns 6 and 8 are just left empty, two consecutive delimiters, just as they are in a csv file.

We can make the changes we want by using further "dot" commands.

There are in fact a large number of "dot" commands and they are all explained in the official SQLite documentation [here](https://sqlite.org/cli.html). One you will have to use at some point is `.quit` which will end the SQLIte shell program.

The commands we need are

```bash
> .mode csv
```

to change the field separator to ",". There are many other modes available see the [documentation](https://sqlite.org/cli.html).

```bash
> .header on
```

to show the column headers

```bash
> .output my.filename
```

to direct the output to a file of my choice.
The file will be created if needed or it will overwrite an already existing file, so exercise care.

![](figures/SQL_08_SQLite_shell_dot_commands.png){alt='SQLite shell dot commands'}

Yes you can have a file called "my.filename" if you want. The contents of which contains the expected output from the query.

![](figures/SQL_08_my_filename.png){alt='SQLite my.filename'}

Notice the use of quotes in the rows where the value of the data item themselves contain quotes; in this case single quotes.

## Automating the use of the SQLite shell

So far we have used the shell in much the same way as we might have used the DB Browser application.
We run the program, connect to a database, run a query and save the output.
Because the shell will accept any valid SQL statements as well as have numerous 'dot' commands of it own
to configure how it works it could be considered as powerful as the DB Browser application.
You could use it as a replacement in most cases.

Most people prefer to work with nice point and click interfaces, so why would you want to use the shell rather than the DB Browser application?

The shell has one distinct advantage over DB Browser; you can run the shell program and in the call to the program provide a parameter indicating
the database to connect to and provide a file of the commands that you want to execute. The shell will execute the file of commands and then exit.

Here is an example

1. create a file `commands.sql` containing the following content:

```sql
result.csv
.mode csv
.output results.csv
.open SQL_SAFI.sqlite
SELECT * from Farms where A09_village='God';
```

2. run the sqlite3 program in the following way

```sh
sqlite3 < commands.sql
```

The shell program will work its way through the commands in the file just as if you had typed them in manually.

There are two clear benefits of taking this approach:

1. It aids automation. It would be straightforward to have the one line command line instruction to be run automatically, perhaps on a timed basis. The SQL statements in the executed file doesn't have to be a simple query. It could be appending rows of data to a series of tables which become available on a regular basis.

2. It aids reproducibility. Although it is convenient to use the DB Browser application to play around and try things out, eventually you will decide on approach, create relevant queries to perform your analysis or research and at this point you will need to ensure that the complete sequence is documented and is reproducible. This is what the file of SQLite commands will do for you.

::: {.callout-note}

## Exercise

The query

```sql
SELECT * from Farms WHERE C01_respondent_roof_type = 'grass';
```

returns all of the records from the Farms table which have a roof made of grass.

Create a file of SQL statements and SQLite shell commands to create 3 files each containing the output from queries like the above but for all three different
roof types (grass, mabatisloping and mabatipitched)

::: {.callout-tip collapse="true"}

## Solution

The contents of your file should be something like this:

```output
.mode csv
.output grass_roofs.csv
select * from Farms where C01_respondent_roof_type = 'grass';
.output mabatisloping_roofs.csv
select * from Farms where C01_respondent_roof_type = 'mabatisloping';
.output mabatipitched_roofs.csv
select * from Farms where C01_respondent_roof_type = 'mabatipitched';
```

The command to run it from the command line is:

```bash
sqlite3 SQL_SAFI.sqlite < SQLite_commands.sql
```

:::
:::

::: {.callout-important}

## Key Points

- SQLite databases can be created, managed and queried from the SQLite shell utility
- You can run the shell interactively from the command line, typing queries or dot commands at the prompt
- You can call the SQLite3 program and specify a database and a set of commands to run. This aids automation
:::
